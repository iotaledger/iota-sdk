"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Setup = void 0;
const react_1 = __importStar(require("react"));
const clipanion_1 = require("clipanion");
const isomorphic_git_1 = __importDefault(require("isomorphic-git"));
const ink_1 = require("ink");
const ink_text_input_1 = __importDefault(require("ink-text-input"));
const ink_select_input_1 = __importDefault(require("ink-select-input"));
const ink_multi_select_1 = __importDefault(require("ink-multi-select"));
const fs_1 = __importDefault(require("fs"));
const axios_1 = __importDefault(require("axios"));
const ink_spinner_1 = __importDefault(require("ink-spinner"));
const parser_1 = require("@babel/parser");
const types_1 = require("@babel/types");
const generator_1 = __importDefault(require("@babel/generator"));
const prettier_1 = __importDefault(require("prettier"));
const InputComponent = (props) => {
    const { isFocused } = (0, ink_1.useFocus)();
    return (react_1.default.createElement(ink_1.Box, { marginRight: 1 },
        react_1.default.createElement(ink_1.Text, { dimColor: !isFocused },
            react_1.default.createElement(ink_1.Text, null,
                props.label,
                ": "),
            react_1.default.createElement(ink_text_input_1.default, { focus: isFocused, showCursor: isFocused, value: props.value, onChange: props.onChange }))));
};
const SelectComponent = (props) => {
    const { isFocused } = (0, ink_1.useFocus)();
    const onSelect = (item) => {
        props.onChange([...props.value, item]);
    };
    const onUnselect = (item) => {
        props.onChange(props.value.filter((o) => o !== item));
    };
    return (react_1.default.createElement(ink_1.Box, { flexDirection: 'column' },
        react_1.default.createElement(ink_1.Text, { dimColor: !isFocused },
            react_1.default.createElement(ink_1.Text, null,
                props.label,
                ": "),
            props.value && (react_1.default.createElement(ink_1.Text, null, props.value
                .map((item) => item.label)
                .sort()
                .join(', ')))),
        react_1.default.createElement(ink_1.Box, { display: isFocused ? 'flex' : 'none' },
            react_1.default.createElement(ink_multi_select_1.default, { focus: isFocused, items: props.items, selected: props.value, onSelect: onSelect, onUnselect: onUnselect }))));
};
const SubmitComponent = (props) => {
    const { isFocused } = (0, ink_1.useFocus)();
    return (react_1.default.createElement(ink_1.Box, { display: isFocused ? 'flex' : 'none', flexDirection: 'column' },
        react_1.default.createElement(ink_1.Text, { color: 'yellow' },
            props.label,
            ":"),
        react_1.default.createElement(ink_select_input_1.default, { isFocused: isFocused, items: props.items, onSelect: (item) => item.value() }),
        react_1.default.createElement(ink_1.Newline, null)));
};
const SetupComponent = (props) => {
    const { focusNext } = (0, ink_1.useFocusManager)();
    const [options, setOptions] = (0, react_1.useState)();
    const [loaded, setLoaded] = (0, react_1.useState)(false);
    const [availableTags, setAvailableTags] = (0, react_1.useState)();
    const [tagsByCategory, setTagsByCategory] = (0, react_1.useState)();
    const getOptions = async () => {
        // TODO First check if a sidebar with valid content exist, else:
        const files = await fs_1.default.promises.readdir('docs');
        const route = files[0].replace(/\.[^/.]+$/, '');
        const dir = await isomorphic_git_1.default.findRoot({
            fs: fs_1.default,
            filepath: process.cwd(),
        });
        const source = await isomorphic_git_1.default.getConfig({
            fs: fs_1.default,
            dir,
            path: 'remote.origin.url',
        });
        setOptions(Object.assign({ route, source }, props.defaultOptions));
    };
    const getAvailableTags = async () => {
        const { data } = await axios_1.default.get('https://raw.githubusercontent.com/iota-community/iota-wiki/feat/tuto-section/content/tutorials/tags.json');
        setAvailableTags(new Map(Object.entries(data)));
    };
    (0, react_1.useEffect)(() => {
        getAvailableTags();
        getOptions();
    }, []);
    (0, react_1.useEffect)(() => {
        if (availableTags) {
            const tagsByCategory = !options.tags
                ? new Map()
                : new Map(Array.from(availableTags, ([category, tags]) => {
                    return [
                        category,
                        tags.filter((tag) => options.tags.includes(tag.value)),
                    ];
                }));
            setTagsByCategory(tagsByCategory);
        }
    }, [availableTags]);
    (0, react_1.useEffect)(() => {
        setLoaded(!!options && !!tagsByCategory);
    }, [options, tagsByCategory]);
    (0, react_1.useEffect)(() => {
        if (loaded)
            focusNext();
    }, [loaded]);
    (0, ink_1.useInput)((_, key) => {
        if (key.escape)
            process.exit();
        if (key.return)
            focusNext();
    });
    const onChangeTags = (category) => (tags) => {
        const newTagsByCategory = tagsByCategory.set(category, tags);
        const newTags = Array.from(newTagsByCategory.values())
            .flat()
            .map((tag) => tag.value);
        setTagsByCategory(newTagsByCategory);
        setOptions({ ...options, tags: newTags });
    };
    const onChangeOption = (option) => (value) => {
        setOptions({ ...options, [option]: value });
    };
    const addPlugin = () => {
        // TODO: Handle invalid or missing required options.
        const normalizedOptions = Object.assign({
            title: '',
            description: '',
            tags: [],
        }, options);
        props.addPlugin(normalizedOptions);
        process.exit();
    };
    return (react_1.default.createElement(ink_1.Box, { flexDirection: 'column' },
        react_1.default.createElement(ink_1.Text, null, "Configure the tutorial using the options below."),
        react_1.default.createElement(ink_1.Box, { flexDirection: 'column', padding: 1 },
            react_1.default.createElement(ink_1.Text, null, "Use ENTER, TAB and SHIFT+TAB to move up or down."),
            react_1.default.createElement(ink_1.Text, null, "Use SPACE to select items.")),
        loaded ? (react_1.default.createElement(react_1.default.Fragment, null,
            react_1.default.createElement(InputComponent, { label: 'Title', value: options.title || '', onChange: onChangeOption('title') }),
            react_1.default.createElement(InputComponent, { label: 'Description', value: options.description || '', onChange: onChangeOption('description') }),
            react_1.default.createElement(InputComponent, { label: 'Preview image path', value: options.preview || '', onChange: onChangeOption('preview') }),
            react_1.default.createElement(InputComponent, { label: 'Route to the tutorial', value: options.route || '', onChange: onChangeOption('route') }),
            Array.from(availableTags, ([category, tags]) => (react_1.default.createElement(SelectComponent, { label: `${category} tags`, items: tags, value: tagsByCategory.get(category) || [], onChange: onChangeTags(category), key: category }))),
            react_1.default.createElement(SubmitComponent, { label: 'Choose what to do', items: [
                    {
                        label: 'Write the config to file.',
                        value: addPlugin,
                    },
                    {
                        label: 'Exit without writing config to file.',
                        value: process.exit,
                    },
                ] }))) : (react_1.default.createElement(ink_1.Text, { color: 'cyan' },
            react_1.default.createElement(ink_spinner_1.default, { type: 'dots' }),
            " Loading data..."))));
};
const SelectTutorialComponent = (props) => {
    const { exit } = (0, ink_1.useApp)();
    const handleSelect = (item) => {
        props.onSelect(item.value);
        exit();
    };
    return (react_1.default.createElement(ink_1.Box, { flexDirection: 'column', marginBottom: 1 },
        react_1.default.createElement(ink_1.Text, null, "Choose a plugin to configure or add a new one: "),
        react_1.default.createElement(ink_select_input_1.default, { items: props.items, onSelect: handleSelect })));
};
function tryModuleExports(statement) {
    if (statement.type === 'ExpressionStatement' &&
        statement.expression.type === 'AssignmentExpression' &&
        statement.expression.left.type === 'MemberExpression' &&
        statement.expression.left.object.type === 'Identifier' &&
        statement.expression.left.object.name === 'module' &&
        statement.expression.left.property.type === 'Identifier' &&
        statement.expression.left.property.name === 'exports') {
        return statement.expression.right;
    }
}
function getConfig(statements) {
    let expression = statements.reduce((previous, current) => previous || tryModuleExports(current), null);
    if (expression === null) {
        expression = (0, types_1.assignmentExpression)('=', (0, types_1.memberExpression)((0, types_1.identifier)('module'), (0, types_1.identifier)('exports')), (0, types_1.objectExpression)([]));
        statements.push((0, types_1.expressionStatement)(expression));
    }
    return expression;
}
function tryPlugins(property) {
    if (property.type === 'ObjectProperty' &&
        property.key.type === 'Identifier' &&
        property.key.name === 'plugins') {
        return property.value;
    }
}
function getPlugins(properties) {
    let plugins = properties.reduce((previous, current) => previous || tryPlugins(current), null);
    if (plugins === null) {
        plugins = (0, types_1.arrayExpression)([]);
        properties.push((0, types_1.objectProperty)((0, types_1.identifier)('plugins'), plugins));
    }
    return plugins;
}
class Setup extends clipanion_1.Command {
    static paths = [[`tutorial`, `configure`]];
    static usage = clipanion_1.Command.Usage({
        description: `Configure the tutorial settings to properly list it on the IOTA Wiki.`,
    });
    async execute() {
        // TODO: Remove hardcoded config file path.
        const filePath = 'docusaurus.config.js';
        const ast = (0, parser_1.parse)(fs_1.default.readFileSync(filePath, 'utf-8'));
        const config = getConfig(ast.program.body);
        // TODO: Allow config exported via variable assigned to `module.exports`.
        if (config.type !== 'ObjectExpression')
            throw 'Module needs to export a config object.';
        const plugins = getPlugins(config.properties);
        // TODO: Allow variable and convert it to variable spread in array literal.
        if (plugins.type !== 'ArrayExpression')
            throw 'Plugins property needs to be an array.';
        const tutorialPlugins = plugins.elements.reduce((plugins, element, index) => {
            if (element.type === 'ArrayExpression') {
                const pluginElement = element.elements[0];
                if (pluginElement.type !== 'StringLiteral' ||
                    pluginElement.value !== '@iota-wiki/plugin-tutorial') {
                    return plugins;
                }
                const optionsElement = element.elements[1];
                if (optionsElement.type !== 'ObjectExpression')
                    return plugins;
                const options = optionsElement.properties.reduce((properties, property) => {
                    if (property.type === 'ObjectProperty' &&
                        property.key.type === 'Identifier') {
                        if (property.value.type === 'StringLiteral') {
                            properties[property.key.name] = property.value.value;
                        }
                        if (property.key.name === 'tags' &&
                            property.value.type === 'ArrayExpression') {
                            properties.tags = property.value.elements.reduce((tags, tag) => {
                                if (tag.type === 'StringLiteral')
                                    tags.push(tag.value);
                                return tags;
                            }, []);
                        }
                    }
                    return properties;
                }, {});
                return plugins.set(index, options);
            }
            return plugins;
        }, new Map());
        let pluginIndex;
        const setPluginIndex = (index) => (pluginIndex = index);
        if (tutorialPlugins.size > 0) {
            const items = Array.from(tutorialPlugins, ([index, options]) => ({
                label: options.title,
                value: index,
            }));
            items.push({
                label: 'Add a new tutorial...',
                value: plugins.elements.length,
            });
            const { waitUntilExit } = (0, ink_1.render)(react_1.default.createElement(SelectTutorialComponent, { items: items, onSelect: setPluginIndex }));
            await waitUntilExit();
            if (pluginIndex === undefined)
                process.exit();
        }
        const addPlugin = (options) => {
            const { tags, ...rest } = options;
            plugins.elements[pluginIndex] = (0, types_1.arrayExpression)([
                (0, types_1.stringLiteral)('@iota-wiki/plugin-tutorial'),
                (0, types_1.objectExpression)([
                    ...Object.entries(rest).map(([key, value]) => (0, types_1.objectProperty)((0, types_1.identifier)(key), (0, types_1.stringLiteral)(value))),
                    (0, types_1.objectProperty)((0, types_1.identifier)('tags'), (0, types_1.arrayExpression)(tags.map((value) => (0, types_1.stringLiteral)(value)))),
                ]),
            ]);
            const { code } = (0, generator_1.default)(ast);
            const formattedCode = prettier_1.default.format(code, {
                filepath: filePath,
                singleQuote: true,
                jsxSingleQuote: true,
                trailingComma: 'all',
            });
            fs_1.default.writeFileSync(filePath, formattedCode);
        };
        const { waitUntilExit } = (0, ink_1.render)(react_1.default.createElement(SetupComponent, { defaultOptions: tutorialPlugins.get(pluginIndex) || {}, addPlugin: addPlugin }));
        await waitUntilExit();
    }
}
exports.Setup = Setup;
