// Copyright 2020-2021 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

use iota_sdk::{
    pow::{
        miner::{get_miner, get_miner_num_workers, MinerBuilder, MinerCancel},
        score::PowScorer,
    },
    types::block::rand::bytes::rand_bytes,
};

#[test]
fn get_miner_score() {
    let miner = get_miner(100);
    let mut bytes = rand_bytes(256);

    let nonce = miner(&bytes[0..248]).unwrap();
    bytes[248..].copy_from_slice(&nonce.to_le_bytes());

    assert!(PowScorer::new().score(&bytes) >= 100f64);
}

#[test]
fn get_miner_num_workers_score() {
    let miner = get_miner_num_workers(100, 4);
    let mut bytes = rand_bytes(256);

    let nonce = miner(&bytes[0..248]).unwrap();
    bytes[248..].copy_from_slice(&nonce.to_le_bytes());

    assert!(PowScorer::new().score(&bytes) >= 100f64);
}

#[test]
fn get_miner_score_4000() {
    let miner = get_miner(4000);
    // Hardcoded bytes instead of randomly generated bytes so the test doesn't take long. Random bytes are still tested
    // in get_miner_score().
    let mut bytes = [
        138, 36, 79, 42, 24, 233, 10, 235, 247, 64, 72, 2, 240, 109, 19, 194, 195, 166, 181, 77, 226, 78, 115, 68, 181,
        26, 83, 185, 108, 46, 49, 91, 110, 147, 79, 230, 159, 238, 200, 232, 254, 105, 239, 186, 6, 207, 184, 31, 135,
        92, 65, 22, 168, 93, 27, 175, 42, 113, 254, 62, 47, 191, 25, 170, 65, 251, 71, 5, 166, 180, 56, 129, 185, 230,
        124, 157, 131, 211, 186, 18, 125, 182, 188, 108, 218, 30, 184, 10, 130, 105, 209, 172, 144, 251, 137, 192, 8,
        61, 99, 59, 56, 87, 213, 210, 216, 75, 126, 245, 28, 23, 50, 63, 2, 80, 160, 240, 17, 11, 176, 165, 22, 164,
        75, 221, 56, 169, 145, 191, 21, 228, 191, 251, 83, 114, 0, 166, 179, 130, 254, 222, 248, 205, 224, 71, 131, 93,
        164, 175, 110, 223, 124, 219, 169, 99, 162, 187, 192, 40, 7, 50, 121, 32, 136, 150, 102, 43, 78, 13, 48, 75,
        107, 153, 205, 237, 102, 252, 169, 38, 30, 136, 147, 124, 116, 21, 243, 5, 67, 22, 134, 173, 85, 66, 188, 167,
        72, 83, 203, 140, 53, 189, 168, 178, 59, 1, 77, 48, 119, 68, 137, 52, 40, 180, 206, 198, 240, 223, 66, 72, 217,
        151, 87, 232, 48, 191, 128, 44, 56, 15, 148, 99, 90, 1, 43, 62, 68, 254, 139, 163, 199, 128, 189, 66, 208, 215,
        157, 88, 243, 199, 0, 0, 0, 0, 0, 0, 0, 0,
    ];

    let nonce = miner(&bytes[0..248]).unwrap();
    bytes[248..].copy_from_slice(&nonce.to_le_bytes());

    assert!(PowScorer::new().score(&bytes) >= 4000f64);
}

#[test]
fn miner_cancel() {
    let cancel = MinerCancel::new();
    let miner = MinerBuilder::new()
        .with_num_workers(4)
        .with_cancel(cancel.clone())
        .finish();
    // Hardcoded bytes instead of randomly generated bytes as there will always be a small probability that random bytes
    // will provide an easy to compute nonce in less than the second we allow to test the miner cancellation.
    let bytes = [
        67, 109, 231, 137, 43, 175, 54, 114, 170, 148, 6, 36, 239, 11, 127, 211, 21, 121, 176, 198, 41, 238, 140, 158,
        184, 230, 40, 174, 37, 119, 134, 21, 218, 50, 244, 44, 21, 138, 196, 122, 31, 226, 6, 109, 91, 217, 142, 176,
        153, 146, 118, 228, 184, 36, 67, 187, 33, 136, 61, 165, 116, 45, 126, 65, 157, 67, 89, 1, 69, 109, 83, 26, 148,
        111, 233, 213, 164, 250, 15, 84, 89, 69, 176, 102, 215, 142, 4, 250, 19, 41, 228, 93, 196, 209, 239, 101, 220,
        23, 127, 195, 147, 142, 125, 220, 233, 224, 150, 155, 130, 43, 202, 152, 194, 37, 245, 186, 255, 202, 204, 9,
        207, 204, 143, 201, 115, 242, 5, 13, 227, 41, 7, 62, 132, 231, 139, 3, 141, 128, 150, 206, 137, 240, 51, 58,
        239, 228, 218, 231, 222, 70, 196, 234, 200, 117, 211, 103, 127, 254, 179, 72, 98, 147, 250, 242, 125, 79, 184,
        161, 175, 78, 173, 237, 61, 93, 79, 121, 219, 156, 129, 162, 229, 248, 107, 193, 80, 185, 205, 70, 201, 75,
        162, 77, 135, 224, 252, 141, 124, 231, 21, 51, 151, 154, 123, 149, 27, 74, 87, 157, 191, 172, 152, 171, 57, 32,
        151, 51, 66, 231, 13, 143, 27, 59, 116, 224, 123, 245, 213, 65, 183, 189, 125, 154, 145, 175, 46, 76, 103, 194,
        152, 222, 102, 50, 8, 233, 160, 125, 153, 64, 91, 100, 234, 113, 108, 220, 171, 192,
    ];
    let now = std::time::Instant::now();
    let handle = std::thread::spawn(move || miner.nonce(&bytes[0..248], 100000));

    std::thread::sleep(std::time::Duration::from_secs(1));

    cancel.trigger();

    assert!(now.elapsed().as_secs() < 2);
    assert!(handle.join().unwrap().is_none());
}
