// Copyright 2020-2021 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

use iota_sdk::{
    pow::{
        miner::{get_miner, get_miner_num_workers, MinerBuilder, MinerCancel},
        score::PowScorer,
    },
    types::block::rand::bytes::rand_bytes,
};

#[test]
fn get_miner_score() {
    let miner = get_miner(100);
    let mut bytes = rand_bytes(256);

    let nonce = miner(&bytes[0..248]).unwrap();
    bytes[248..].copy_from_slice(&nonce.to_le_bytes());

    assert!(PowScorer::new().score(&bytes) >= 100f64);
}

#[test]
fn get_miner_num_workers_score() {
    let miner = get_miner_num_workers(100, 4);
    let mut bytes = rand_bytes(256);

    let nonce = miner(&bytes[0..248]).unwrap();
    bytes[248..].copy_from_slice(&nonce.to_le_bytes());

    assert!(PowScorer::new().score(&bytes) >= 100f64);
}

#[test]
fn get_miner_score_4000() {
    let miner = get_miner(4000);
    // Hardcoded bytes instead of randomly generated bytes so the test doesn't take long. Random bytes are still tested
    // in get_miner_score().
    let mut bytes = [
        112, 216, 146, 41, 220, 200, 153, 49, 51, 80, 2, 170, 210, 141, 41, 189, 157, 199, 34, 253, 88, 136, 37, 230,
        252, 177, 36, 90, 82, 249, 190, 10, 135, 108, 47, 148, 32, 148, 22, 157, 80, 200, 153, 233, 242, 72, 70, 68,
        33, 218, 235, 80, 244, 200, 77, 39, 139, 11, 222, 243, 84, 49, 181, 8, 165, 19, 134, 106, 237, 192, 0, 172, 78,
        86, 89, 55, 11, 132, 47, 230, 97, 141, 21, 239, 0, 121, 233, 150, 239, 145, 81, 80, 23, 20, 201, 137, 6, 227,
        24, 142, 197, 201, 88, 36, 109, 74, 64, 152, 10, 195, 38, 127, 157, 194, 185, 176, 64, 190, 159, 203, 211, 101,
        55, 168, 18, 190, 125, 239, 130, 103, 164, 233, 124, 145, 53, 30, 35, 112, 12, 192, 40, 39, 24, 115, 44, 48,
        52, 72, 208, 84, 64, 47, 200, 13, 150, 4, 52, 52, 207, 42, 104, 114, 112, 245, 1, 140, 228, 3, 117, 221, 26,
        56, 222, 27, 151, 248, 93, 72, 165, 99, 237, 60, 134, 44, 141, 70, 98, 162, 254, 139, 161, 110, 1, 79, 232, 89,
        247, 86, 223, 123, 2, 164, 204, 152, 41, 48, 33, 47, 141, 32, 216, 235, 187, 138, 11, 112, 187, 164, 119, 78,
        243, 69, 14, 229, 86, 153, 92, 61, 2, 196, 190, 225, 151, 75, 73, 59, 154, 126, 149, 165, 250, 147, 176, 79,
        146, 45, 13, 90, 0, 0, 0, 0, 0, 0, 0, 0,
    ];

    let nonce = miner(&bytes[0..248]).unwrap();
    bytes[248..].copy_from_slice(&nonce.to_le_bytes());

    assert!(PowScorer::new().score(&bytes) >= 4000f64);
}

#[test]
fn miner_cancel() {
    let cancel = MinerCancel::new();
    let miner = MinerBuilder::new()
        .with_num_workers(4)
        .with_cancel(cancel.clone())
        .finish();
    // Hardcoded bytes instead of randomly generated bytes as there will always be a small probability that random bytes
    // will provide an easy to compute nonce in less than the second we allow to test the miner cancellation.
    let bytes = [
        67, 109, 231, 137, 43, 175, 54, 114, 170, 148, 6, 36, 239, 11, 127, 211, 21, 121, 176, 198, 41, 238, 140, 158,
        184, 230, 40, 174, 37, 119, 134, 21, 218, 50, 244, 44, 21, 138, 196, 122, 31, 226, 6, 109, 91, 217, 142, 176,
        153, 146, 118, 228, 184, 36, 67, 187, 33, 136, 61, 165, 116, 45, 126, 65, 157, 67, 89, 1, 69, 109, 83, 26, 148,
        111, 233, 213, 164, 250, 15, 84, 89, 69, 176, 102, 215, 142, 4, 250, 19, 41, 228, 93, 196, 209, 239, 101, 220,
        23, 127, 195, 147, 142, 125, 220, 233, 224, 150, 155, 130, 43, 202, 152, 194, 37, 245, 186, 255, 202, 204, 9,
        207, 204, 143, 201, 115, 242, 5, 13, 227, 41, 7, 62, 132, 231, 139, 3, 141, 128, 150, 206, 137, 240, 51, 58,
        239, 228, 218, 231, 222, 70, 196, 234, 200, 117, 211, 103, 127, 254, 179, 72, 98, 147, 250, 242, 125, 79, 184,
        161, 175, 78, 173, 237, 61, 93, 79, 121, 219, 156, 129, 162, 229, 248, 107, 193, 80, 185, 205, 70, 201, 75,
        162, 77, 135, 224, 252, 141, 124, 231, 21, 51, 151, 154, 123, 149, 27, 74, 87, 157, 191, 172, 152, 171, 57, 32,
        151, 51, 66, 231, 13, 143, 27, 59, 116, 224, 123, 245, 213, 65, 183, 189, 125, 154, 145, 175, 46, 76, 103, 194,
        152, 222, 102, 50, 8, 233, 160, 125, 153, 64, 91, 100, 234, 113, 108, 220, 171, 192,
    ];
    let now = std::time::Instant::now();
    let handle = std::thread::spawn(move || miner.nonce(&bytes[0..248], 100000));

    std::thread::sleep(std::time::Duration::from_secs(1));

    cancel.trigger();

    assert!(now.elapsed().as_secs() < 2);
    assert!(handle.join().unwrap().is_none());
}
