// Copyright 2023 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

use getset::CopyGetters;
use packable::{prefix::BoxedSlicePrefix, Packable};

use crate::types::block::{
    protocol::ProtocolParameters,
    slot::{EpochIndex, SlotIndex},
    Error,
};

#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Packable, CopyGetters)]
#[cfg_attr(
    feature = "serde",
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[packable(unpack_error = Error)]
#[getset(get_copy = "pub")]
pub struct ManaStructure {
    /// The number of bits used to represent Mana.
    pub(crate) bits_count: u8,
    /// The amount of potential Mana generated by 1 IOTA in 1 slot.
    pub(crate) generation_rate: u8,
    /// The scaling of `mana_generation_rate` expressed as an exponent of 2.
    pub(crate) generation_rate_exponent: u8,
    /// A lookup table of epoch index diff to mana decay factor.
    #[packable(unpack_error_with = |_| Error::InvalidManaDecayFactors)]
    #[cfg_attr(feature = "serde", serde(with = "crate::utils::serde::boxed_slice_prefix"))]
    #[getset(skip)]
    pub(crate) decay_factors: BoxedSlicePrefix<u32, u16>,
    /// The scaling of `decay_factors` expressed as an exponent of 2.
    pub(crate) decay_factors_exponent: u8,
    /// An integer approximation of the sum of decay over epochs.
    pub(crate) decay_factor_epochs_sum: u32,
    /// The scaling of `mana_decay_factor_epochs_sum` expressed as an exponent of 2.
    pub(crate) decay_factor_epochs_sum_exponent: u8,
}

impl ManaStructure {
    /// Returns the mana decay factors slice.
    pub fn decay_factors(&self) -> &[u32] {
        &self.decay_factors
    }

    /// Returns the mana decay factor for the given epoch index.
    pub fn decay_factor_at(&self, epoch_index: impl Into<EpochIndex>) -> Option<u32> {
        self.decay_factors.get(*epoch_index.into() as usize).copied()
    }

    /// Returns the max mana that can exist with the mana bits defined.
    pub fn max_mana(&self) -> u64 {
        (1 << self.bits_count) - 1
    }

    pub fn decay(&self, mana: u64, epoch_delta: u64) -> u64 {
        if mana == 0 || epoch_delta == 0 {
            return mana;
        }

        // split the value into two uint64 variables to prevent overflowing
        let mut mana_hi = upper_bits(mana);
        let mut mana_lo = lower_bits(mana);

        // we keep applying the lookup table factors as long as n epochs are left
        let mut remaining_epochs = epoch_delta;

        while remaining_epochs > 0 {
            let epochs_to_decay = remaining_epochs.min(self.decay_factors().len() as u64);
            remaining_epochs -= epochs_to_decay;

            // Unwrap: Safe because the index is at most the length
            let decay_factor = self.decay_factor_at(epochs_to_decay - 1).unwrap();

            // apply the decay using fixed-point arithmetics.
            (mana_hi, mana_lo) =
                multiplication_and_shift(mana_hi, mana_lo, decay_factor, self.decay_factors_exponent());
        }

        // combine both uint64 variables to get the actual value
        mana_hi << 32 | mana_lo
    }

    pub(crate) fn generate_mana(&self, amount: u64, slot_delta: u32) -> u64 {
        if self.generation_rate() == 0 || slot_delta == 0 {
            return 0;
        }
        let amount_hi = upper_bits(amount);
        let amount_lo = lower_bits(amount);
        let (amount_hi, amount_lo) = multiplication_and_shift(
            amount_hi,
            amount_lo,
            slot_delta * self.generation_rate() as u32,
            self.generation_rate_exponent(),
        );
        amount_hi << 32 | amount_lo
    }
}

impl Default for ManaStructure {
    fn default() -> Self {
        // TODO: use actual values
        Self {
            bits_count: 10,
            generation_rate: Default::default(),
            generation_rate_exponent: Default::default(),
            decay_factors: Default::default(),
            decay_factors_exponent: Default::default(),
            decay_factor_epochs_sum: Default::default(),
            decay_factor_epochs_sum_exponent: Default::default(),
        }
    }
}

impl ProtocolParameters {
    /// Calculates the potential mana that is generated by holding `amount` tokens from `slot_index_created` to
    /// `slot_index_target` and applies the decay to the result
    pub fn potential_mana(&self, amount: u64, slot_index_created: SlotIndex, slot_index_target: SlotIndex) -> u64 {
        if slot_index_created >= slot_index_target {
            return 0;
        }
        let slots_per_epoch_exp = self.slots_per_epoch_exponent();
        let mana_structure = self.mana_structure();
        let (epoch_index_created, epoch_index_target) = (
            slot_index_created.to_epoch_index(slots_per_epoch_exp),
            slot_index_target.to_epoch_index(slots_per_epoch_exp),
        );
        if epoch_index_created == epoch_index_target {
            mana_structure.generate_mana(amount, (*slot_index_target - *slot_index_created) as u32)
        } else if epoch_index_created == epoch_index_target - 1 {
            let slots_before_next_epoch =
                *slot_index_created - **(epoch_index_created + 1).slot_index_range(slots_per_epoch_exp).start();
            let slots_since_epoch_start =
                *slot_index_target - **(epoch_index_target - 1).slot_index_range(slots_per_epoch_exp).end();
            let mana_decayed =
                mana_structure.decay(mana_structure.generate_mana(amount, slots_before_next_epoch as u32), 1);
            let mana_generated = mana_structure.generate_mana(amount, slots_since_epoch_start as u32);
            mana_decayed + mana_generated
        } else {
            let c = {
                let amount_hi = upper_bits(amount);
                let amount_lo = lower_bits(amount);
                let (amount_hi, amount_lo) = multiplication_and_shift(
                    amount_hi,
                    amount_lo,
                    mana_structure.decay_factor_epochs_sum() * mana_structure.generation_rate() as u32,
                    mana_structure.decay_factor_epochs_sum_exponent() + mana_structure.generation_rate_exponent()
                        - slots_per_epoch_exp,
                );
                amount_hi << 32 | amount_lo
            };
            let slots_before_next_epoch =
                *slot_index_created - **(epoch_index_created + 1).slot_index_range(slots_per_epoch_exp).start();
            let slots_since_epoch_start =
                *slot_index_target - **(epoch_index_target - 1).slot_index_range(slots_per_epoch_exp).end();
            let potential_mana_n = mana_structure.decay(
                mana_structure.generate_mana(amount, slots_before_next_epoch as u32),
                *epoch_index_target - *epoch_index_created,
            );
            let potential_mana_n_1 = mana_structure.decay(c, *epoch_index_target - *epoch_index_created);
            let potential_mana_0 = c + mana_structure.generate_mana(amount, slots_since_epoch_start as u32)
                - (c >> mana_structure.generation_rate_exponent());
            potential_mana_0 - potential_mana_n_1 + potential_mana_n
        }
    }
}

/// Returns the upper 32 bits of a u64 value.
fn upper_bits(v: u64) -> u64 {
    v >> 32
}

/// Returns the lower n bits of a u64 value.
fn lower_n_bits(v: u64, n: u8) -> u64 {
    debug_assert!(n <= 64);
    v & u64::MAX >> (64 - n)
}

/// Returns the lower 32 bits of a u64 value.
fn lower_bits(v: u64) -> u64 {
    v & 0xFFFFFFFF
}

/// Returns the result of the multiplication ((value_hi << 32 + value_lo) * mult_factor) >> shift_factor
/// (where mult_factor is a uint32, value_hi and value_lo are uint64 smaller than 2^32, and 0 <= shift_factor <=
/// 32), using only uint64 multiplication functions, without overflowing. The returned result is split
/// in 2 factors: value_hi and value_lo, one containing the upper 32 bits of the result and the other
/// containing the lower 32 bits.
fn multiplication_and_shift(mut value_hi: u64, mut value_lo: u64, mult_factor: u32, shift_factor: u8) -> (u64, u64) {
    debug_assert!(shift_factor <= 32);
    // multiply the integer part of value_hi by mult_factor
    value_hi = value_hi * mult_factor as u64;

    // the lower shift_factor bits of the result are extracted and shifted left to form the remainder.
    // value_lo is multiplied by mult_factor and right-shifted by shift_factor bits.
    // the sum of these two values forms the new lower part (value_lo) of the result.
    value_lo =
        (lower_n_bits(value_hi, shift_factor) << (32 - shift_factor)) + (value_lo * mult_factor as u64) >> shift_factor;

    // the right-shifted value_hi and the upper 32 bits of value_lo form the new higher part (value_hi) of the
    // result.
    value_hi = (value_hi >> shift_factor) + upper_bits(value_lo);

    // the lower 32 bits of value_lo form the new lower part of the result.
    value_lo = lower_bits(value_lo);

    // return the result as a fixed-point number composed of two 64-bit integers
    (value_hi, value_lo)
}
